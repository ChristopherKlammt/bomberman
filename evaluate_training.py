import numpy as npimport tablesfrom matplotlib import pyplot as pltfrom argparse import ArgumentParserfrom agent_code.dqn.parameters import (FILENAME)FILENAME = 'max_boltzmann2.h5'ROW_SIZE = 5# 1. Change filename in parameters.py# 2. 'python evaluate_training.py create'# 3. Adapt training hyperparameters in parameters# 4. train model with saving data (evaluate = True)# 5. python evaluate_training.py def evaluate(filename):    # Properties:    # Influence of rule-based model: 1.2 --> 0.2 in 100 rounds    # Auxiliary rewards: walk -0.2, wait -10, coin_collected 5,     #   new_location_visited 2, already_visited -0.5, moved_towards_coin 0.1, moved_away_from_coin -0.1    # Number of coins: 72    # Field size: default        step_size = 20        # read the data saved in <filename>    file = tables.open_file(filename, mode='r')    number_of_steps = file.root.data[:,0]    auxiliary_reward = file.root.data[:,1]    collected_coins = file.root.data[:,2]    killed_opponents = file.root.data[:,3]    self_kill = file.root.data[:,4]        y = np.array(file.root.data)    len_of_y = int(float(np.shape(y)[0]/step_size)) # number of groups after combining STEP_SIZE values to one     y_mean = np.empty((len_of_y, np.shape(y)[1]))    y_std = np.empty((len_of_y, np.shape(y)[1]))        y[:,4] *= 100 # multiply self kills with 100 to get the percentage of self kills by computing the mean        # compute mean and standard deviation over step_size training rounds    for i in range(len_of_y):        y_i = y[step_size*i:step_size*(i+1)].astype(np.float)        for j in range(np.shape(y)[1]):            y_mean[i,j] = np.mean(y_i[:,j])            y_std[i,j]  = np.std(y_i[:,j])       x = np.arange(step_size, (len_of_y+1)*step_size, step_size)            plt.errorbar(x, y_mean[:,0], y_std[:,0], label = 'number of steps')    plt.errorbar(x, y_mean[:,1], y_std[:,1], label = 'total reward including auxiliary reward')    plt.errorbar(x, y_mean[:,2], y_std[:,2], label = 'collected coins per round')    plt.errorbar(x, y_mean[:,3], y_std[:,3], label = 'killed opponents')    plt.plot(x, y_mean[:,4], label = 'percentage of rounds ended by self kill')        plt.xlabel('number of training rounds')    plt.legend()    plt.show()    def create(filename, row_size, num_columns):    # create an extendable EArray storage        file = tables.open_file(filename, mode='w')    atom = tables.Float64Atom()    data_array = file.create_earray(file.root, 'data', atom, (0, row_size))    file.close()        parser = ArgumentParser()subparsers = parser.add_subparsers(dest='command_name', required=False)create_parser = subparsers.add_parser("create")args = parser.parse_args()if args.command_name == "create":    create(FILENAME, ROW_SIZE, 0)else:    evaluate(FILENAME)        