import numpy as npimport tablesfrom matplotlib import pyplot as pltfrom argparse import ArgumentParserFILENAME = 'max_boltzmann2.h5'# 1. Change filename of evaluate_training.py AND train.py# 2. 'python evaluate_training.py create'# 3. Adapt training hyperparameters in callbacks.py# 4. train model with saving data to the right file# 5. python evaluate_training.py def evaluate(filename):    # Properties:    # Influence of rule-based model: 1.2 --> 0.2 in 100 rounds    # Auxiliary rewards: walk -0.2, wait -10, coin_collected 5,     #   new_location_visited 2, already_visited -0.5, moved_towards_coin 0.1, moved_away_from_coin -0.1    # Number of coins: 72    # Field size: default        step_size = 50        # read the data saved in <filename>    file = tables.open_file(filename, mode='r')    number_of_steps = file.root.data[:,0]    auxiliary_reward = file.root.data[:,1]        y1_mean,y2_mean = [],[]    y1_std, y2_std = [],[]        # compute mean and standard deviation of step_size training steps    for i in range(int(float(len(number_of_steps)/step_size))):        y1 = np.array(number_of_steps[step_size*i:step_size*(i+1)]).astype(np.float)        y1_mean.append(np.mean(y1))        y1_std.append(np.std(y1))        y2 = np.array(auxiliary_reward[step_size*i:step_size*(i+1)]).astype(np.float)        y2_mean.append(np.mean(y2))        y2_std.append(np.std(y2))            x = np.arange(step_size, (len(y1_mean)+1)*step_size, step_size)            plt.errorbar(x, y1_mean, y1_std, label = 'number of steps')    plt.errorbar(x, y2_mean, y2_std, label = 'total reward including auxiliary reward')    plt.xlabel('number of training rounds')    plt.legend()    plt.show()    def create(filename, row_size, num_columns):    # create an extendable EArray storage    file = tables.open_file(filename, mode='w')    atom = tables.Float64Atom()    data_array = file.create_earray(file.root, 'data', atom, (0, row_size))    file.close()        parser = ArgumentParser()subparsers = parser.add_subparsers(dest='command_name', required=False)create_parser = subparsers.add_parser("create")args = parser.parse_args()if args.command_name == "create":    create(FILENAME, 2, 0)else:    evaluate(FILENAME)        